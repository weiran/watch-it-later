//
//  AsyncImageView.h
//
//  Version 1.6
//
//  Created by Nick Lockwood on 03/04/2011.
//  Copyright (c) 2011 Charcoal Design
//
//  Distributed under the permissive zlib License
//  Get the latest version from here:
//
//  https://github.com/nicklockwood/AsyncImageView
//
//  This software is provided 'as-is', without any express or implied warranty.
//  In no event will the authors be held liable for any damages arising from the
//  use of this software.
//
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//
//  1. The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software in a
//  product, an acknowledgment in the product documentation would be appreciated
//  but is not required.
//
//  2. Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//
//  3. This notice may not be removed or altered from any source distribution.
//


#import <UIKit/UIKit.h>
#import <QuartzCore/QuartzCore.h>
#import <ImageIO/ImageIO.h>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wobjc-missing-property-synthesis"

NS_ASSUME_NONNULL_BEGIN

/**
 * Error domain string for AsyncImageLoader errors.
 */
extern NSString *const AsyncImageLoaderErrorDomain;

/**
 * This fires when an image has been loaded. The notification object contains
 * the target object that loaded the image file (e.g. the UIImageView) and the
 * userInfo dictionary contains the following keys:
 * - AsyncImageImageKey
 * - AsyncImageURLKey
 * - AsyncImageCacheKey
 */
extern NSString *const AsyncImageLoadDidFinish;

/**
 * This fires when an image did not load due to an error. The notification object
 * contains the target object that attempted to load the image file (e.g. the
 * UIImageView) and the userInfo dictionary contains the following keys:
 * - AsyncImageErrorKey
 * - AsyncImageURLKey
 */
extern NSString *const AsyncImageLoadDidFail;

/**
 * The UIImage that was loaded.
 */
extern NSString *const AsyncImageImageKey;

/**
 * The NSURL that the image was loaded from (or failed to load from).
 */
extern NSString *const AsyncImageURLKey;

/**
 * The NSCache that the image was stored in.
 */
extern NSString *const AsyncImageCacheKey;

/**
 * The NSError generated by the underlying NSURLSession
 */
extern NSString *const AsyncImageErrorKey;


/**
 * AsyncImageLoader manages the loading/downloading and queueing of image
 * requests. Set properties of the shared loader instance to control loading
 * behaviour, or call its loading methods directly to preload images off-screen.
 */
@interface AsyncImageLoader : NSObject

/**
 * The default loader instance used for image requests.
 */
+ (AsyncImageLoader *)sharedLoader;

/**
 * The default cache instance used by image loaders.
 */
+ (NSCache *)defaultCache;

/**
 * The cache to be used for image load requests. You can change this value at
 * any time and it will affect all subsequent load requests until it is changed
 * again. By default this is set to `[AsyncImageLoader sharedCache]`. Set this
 * to nil to disable caching completely, or you can set it to a new NSCache
 * instance or subclass for fine-grained cache control.
 */
@property (nonatomic, strong, nullable) NSCache *cache;

/**
 * The number of images to load concurrently. Images are loaded on background
 * threads but loading too many concurrently can choke the CPU.
 * The default value is 4.
 */
@property (nonatomic, assign) NSUInteger concurrentLoads;

/**
 * The loading timeout, in seconds. This defaults to 60, which should be more
 * than enough for loading over WiFi, but may be too short for downloading large
 * images over a slow 2G/3G connection.
 */
@property (nonatomic, assign) NSTimeInterval loadingTimeout;

/**
 * This queues an image for download. If the queue is empty and the image is
 * already in cache, this will trigger the success action immediately.
 *
 * The target is retained by the AsyncImageLoader, however the loader will
 * monitor to see if the target is being retained by any other objects, and will
 * release it and terminate the file load if it is not. The target can be nil,
 * in which case the load will still happen as normal and can completion can be
 * detected using the `AsyncImageLoadDidFinish` and `AsyncImageLoadDidFail`
 * notifications.
 */
- (void)loadImageWithURL:(nullable NSURL *)URL
                  target:(nullable id)target
                 success:(nullable SEL)success
                 failure:(nullable SEL)failure;

/**
 * Works the same as above, except the action will only be called if the loading
 * is successful. Failure can still be detected using the `AsyncImageLoadDidFail`
 * notification.
 */
- (void)loadImageWithURL:(nullable NSURL *)URL
                  target:(nullable id)target
                  action:(nullable SEL)action;

/**
 * Works the same as above, but no target or actions are specified. Use
 * `AsyncImageLoadDidFinish` and `AsyncImageLoadDidFail` to detect when the
 * loading is complete.
 */
- (void)loadImageWithURL:(nullable NSURL *)URL;

/**
 * This cancels loading the image with the specified URL for the specified
 * target and action.
 */
- (void)cancelLoadingURL:(nullable NSURL *)URL
                  target:(nullable id)target
                  action:(nullable SEL)action;

/**
 * This cancels loading the image with the specified URL for any actions on the
 * specified target;
 */
- (void)cancelLoadingURL:(nullable NSURL *)URL
                  target:(nullable id)target;

/**
 * This cancels loading the image with the specified URL.
 */
- (void)cancelLoadingURL:(nullable NSURL *)URL;

/**
 * This cancels loading all queued image URLs with the specified action on the
 * specified target;
 */
- (void)cancelLoadingImagesForTarget:(nullable id)target
                              action:(nullable SEL)action;

/**
 * This cancels loading all queued image URLs for the specified target;
 */
- (void)cancelLoadingImagesForTarget:(nullable id)target;

/**
 * Returns the most recent image URL assigned to the target for the given action.
 * This is not necessarily the next image that will be assigned if several image
 * URLs have been queued on that target.
 */
- (NSURL *)URLForTarget:(nullable id)target
                 action:(nullable SEL)action;

/**
 * Returns the most recent image URL assigned to the target.
 * This is not necessarily the next image that will be assigned if several image
 * URLs have been queued on that target.
 */
- (NSURL *)URLForTarget:(nullable id)target;

@end


/**
 * a category on UIImageView. This implements provides an `imageURL` property
 * that can be used to trigger an asynchronous load of a new image.
 */
@interface UIImageView(AsyncImageView)

/**
 * Upon setting this property, AsyncImageView will begin loading/downloading the
 * specified image on a background thread. Once the image file has loaded, the
 * UIImageView's image property will be set to the resultant image. If you set
 * this property again while the previous image is still loading then the images
 * will be queued for loading in the order in which they were set.
 *
 * This means that you can, for example, set a UIImageView to load a small
 * thumbnail image and then immediately set it to load a larger image and the
 * thumbnail image will still be loaded and set before the larger image loads.
 *
 * If you access this property it will return the most recent image URL set for
 * the UIImageView, which may not be the next one to be loaded if several image
 * URLs have been queued on that image view. If you wish to cancel the
 * previously loading image, use the `-cancelLoadingURL:target:` method on the
 * AsyncImageLoader class, passing the UIImageView instance as the target.
 */
@property (nonatomic, strong, nullable) NSURL *imageURL;

@end


/**
 * a subclass of UIImageView. This implements some useful features on top of the
 * UIImageView category, including the automatic display of a loading spinner,
 * and a nice crossfade effect when the image loads.
 */
@interface AsyncImageView : UIImageView

/**
 * If YES, the AsyncImageView will display a loading spinner when the imageURL
 * is set. This will automatically hide once the image has loaded. Note that
 * this value should bet set *before* setting the imageURL. Setting this value
 * when loading is already in progress will have no effect. Defaults to YES.
 */
@property (nonatomic, assign) BOOL showActivityIndicator;

/**
 * The style that will be used for the UIActivityIndicator (if enabled). Note
 * that this value should bet set *before* setting the imageURL. Setting this
 * value when loading is already in progress will cause the spinner to disappear.
 */
@property (nonatomic, assign) UIActivityIndicatorViewStyle activityIndicatorStyle;

/**
 * The color for the UIActivityIndicator. Defaults to light grey.
 */
@property (nonatomic, strong, nullable) UIColor *activityIndicatorColor;

/**
 * The crossfade animation duration, in seconds. If value is greater than 0, the
 * image will crossfade in once it loads instead of appearing suddenly. Defaults
 * to 0.4.
 */
@property (nonatomic, assign) NSTimeInterval crossfadeDuration;

@end

NS_ASSUME_NONNULL_END

#pragma clang diagnostic pop

